#!/usr/bin/env bash
set -euo pipefail

# ===================================
# METADATA
# ===================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="1.1.0"

# ===================================
# COLORS
# ===================================
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
	readonly RED=$'\033[0;31m'
	readonly GREEN=$'\033[0;32m'
	readonly YELLOW=$'\033[0;33m'
	readonly BLUE=$'\033[0;34m'
	readonly MAGENTA=$'\033[0;35m'
	readonly BOLD=$'\033[1m'
	readonly DIM=$'\033[2m'
	readonly NC=$'\033[0m'
else
	readonly RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' BOLD='' DIM='' NC=''
fi

# ===================================
# CONFIGURATION
# ===================================
DEBUG=false
QUIET=false

# Default configuration
BACKUP_DIR="$HOME/Backups/system"
DESTINATION="$HOME"
TMP_DIR="/tmp"
PORT=8000
NOTIFY=true
VERBOSE=false
COMPRESSION_LEVEL="-0"
OUTPUT_NAME=""
DUNST_ID=91190
DIRS_TO_BACKUP=(
	"$HOME/artifacts"
	"$HOME/Backups"
	"$HOME/dockerhub"
	"$HOME/Documents"
	"$HOME/git"
	"$HOME/npm"
	"$HOME/Pictures"
	"$HOME/server"
	"$HOME/work"
)
EXCLUDE_PATTERN=(
	"*/node_modules/*"
	"*/dist/*"
	"*/build/*"
	"*/.next/*"
	"*/.pnpm/*"
	"*.zip"
	"*.tar.gz"
	"*.log"
	"*.tmp"
)

# ===================================
# LOGGING FUNCTIONS
# ===================================
log() { [[ "$QUIET" != true ]] && printf "${BLUE}▶${NC} %s\n" "$*" || true; }
warn() { printf "${YELLOW}⚠${NC} %s\n" "$*" >&2; }
error() { printf "${RED}✗${NC} %s\n" "$*" >&2; }
success() { [[ "$QUIET" != true ]] && printf "${GREEN}✓${NC} %s\n" "$*" || true; }
debug() { [[ "$DEBUG" == true ]] && printf "${MAGENTA}⚈${NC} DEBUG: %s\n" "$*" >&2 || true; }
die() {
	error "$*"
	exit 1
}

# ========================
# UTILITIES
# ========================
require_cmd() {
	command -v "$1" >/dev/null 2>&1 || die "'$1' is not installed or not in PATH."
}

notify() {
	$NOTIFY && dunstify "Backup" "$1" -r $DUNST_ID || true
}

notify_progress() {
	local percent="$1"
	local message="$2"
	$NOTIFY && dunstify "Backup Progress" "$message" -h int:value:$percent -r $DUNST_ID || true
}

# ===================================
# COMMANDS
# ===================================
cmd_help() {
	cat <<EOF
${BOLD}${SCRIPT_NAME}${NC} - A simple backup and restore utility

${BOLD}USAGE:${NC}
  $SCRIPT_NAME [OPTIONS] COMMAND

${BOLD}COMMANDS:${NC}
  ${GREEN}create${NC}              Create a backup
  ${GREEN}share${NC}               Share latest backup via HTTP
  ${GREEN}download${NC}            Download and restore from remote backup server
  ${GREEN}restore${NC}             Restore from local .zip backup
  ${GREEN}list${NC}                List local backup files
  ${GREEN}help${NC}                Show this help message
  ${GREEN}version${NC}             Show script version

${BOLD}OPTIONS:${NC}
  ${YELLOW}--dir <DIR>${NC}                   Directory to store backups (default: $BACKUP_DIR)
  ${YELLOW}--file <FILE>${NC}                 Path to the local zip file to restore from
  ${YELLOW}--dest <DIR>${NC}                  Restore destination directory (default: $DESTINATION)
  ${YELLOW}--tmp <DIR>${NC}                   Temp working directory (default: $TMP_DIR)
  ${YELLOW}--ip${NC}                          IP address of the remote server to download the backup from
  ${YELLOW}--port <PORT>${NC}                 HTTP port to share/download (default: $PORT)
  ${YELLOW}--output <NAME>${NC}               Override output backup file name
  ${YELLOW}--dirs <D1,D2>${NC}                Comma-separated directories to back up
  ${YELLOW}--exclude <PATTS>${NC}             Comma-separated exclude patterns
  ${YELLOW}--compress <0|9>${NC}              Zip compression level (default: 0)
  ${YELLOW}--no-notify${NC}                   Disable dunstify popups
  ${YELLOW}-q, --quiet${NC}                   Minimize output
  ${YELLOW}-d, --debug${NC}                   Enable debug output
  ${YELLOW}-h, --help${NC}                    Show help
  ${YELLOW}-v, --version${NC}                 Show version

${BOLD}EXAMPLES:${NC}
  $SCRIPT_NAME create --dir ~/Backups --dest ~/Restore
  $SCRIPT_NAME share
  $SCRIPT_NAME download
EOF
}

cmd_create() {
	mkdir -p "$BACKUP_DIR"
	local filename="${OUTPUT_NAME:-backup-$(date +%Y%m%d%H%M%S).zip}"
	local path="$BACKUP_DIR/$filename"
	log "Creating: $path"
	notify "Creating backup..."
	local tmp_list
	tmp_list=$(mktemp)
	for dir in "${DIRS_TO_BACKUP[@]}"; do
		if [[ -d "$dir" ]]; then
			find "$dir" -type f | sed "s|^$HOME/||" >>"$tmp_list"
		fi
	done
	pushd "$HOME" >/dev/null
	local zip_args=(-r "$COMPRESSION_LEVEL" "$path" -@)
	for pattern in "${EXCLUDE_PATTERN[@]}"; do
		zip_args+=(-x "$pattern")
	done
	if $VERBOSE; then
		zip -v "${zip_args[@]}" <"$tmp_list"
	else
		(
			zip "${zip_args[@]}" <"$tmp_list" >/dev/null 2>&1
			rm -f "$tmp_list"
		) &
		local zip_pid=$!
		local percent=0 step=3
		while kill -0 "$zip_pid" 2>/dev/null; do
			sleep 1
			percent=$((percent + step))
			[[ $percent -gt 99 ]] && percent=99
			notify_progress "$percent" "Creating backup: $filename ($percent%)"
		done
		wait "$zip_pid"
	fi
	rm -f "$tmp_list"
	popd >/dev/null
	notify_progress 100 "Backup complete: $filename"
	notify "Backup complete: $filename"
	success "Backup ready: $path"
}

cmd_share() {
	require_cmd python3
	require_cmd ln
	[[ ! -d "$BACKUP_DIR" ]] && die "Backup directory not found: $BACKUP_DIR"
	local latest_zip
	latest_zip=$(ls -1t "$BACKUP_DIR"/backup-*.zip 2>/dev/null | head -n 1)
	[[ -z "$latest_zip" ]] && die "No backup files to share."
	local filename
	filename=$(basename "$latest_zip")
	local share_dir="$TMP_DIR/backup_share"
	rm -rf "$share_dir" && mkdir -p "$share_dir"
	ln -s "$latest_zip" "$share_dir/$filename"
	cat <<EOF >"$share_dir/index.html"
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="refresh" content="0; url=$filename" />
  </head>
  <body>
    <p>Redirecting to download <a href="$filename">$filename</a>...</p>
  </body>
</html>
EOF
	local ip
	ip=$(hostname -I | awk '{print $1}')
	log "Serving backup at: http://$ip:$PORT/"
	notify "Sharing: $filename"
	cd "$share_dir"
	python3 -m http.server "$PORT" >/dev/null 2>&1
}

cmd_restore() {
	local file="$1"
	[[ ! -f "$file" ]] && {
		die "File not found: $file"
	}
	notify "Restoring from $file"
	unzip "$file" -d "$TMP_DIR"
	local source="$TMP_DIR"
	local total=$(find "$source" -type f 2>/dev/null | wc -l)
	[[ "$total" -eq 0 ]] && total=100
	local count=0
	local prev_percent=0
	notify_progress 0 "Restoring from $file (0%)"
	rsync -av --log=progress2 --remove-source-files --ignore-existing "$source/" "$DESTINATION/" | while read -r line; do
		if [[ "$line" =~ to-check ]]; then
			((count++))
			local percent=$((100 * count / total))
			[[ $percent -gt 100 ]] && percent=100
			if [[ $percent -ne $prev_percent ]]; then
				prev_percent=$percent
				notify_progress "$percent" "Restoring from $file ($percent%)"
			fi
		fi
	done
	notify_progress 100 "Restore complete"
	notify "Restore complete: $file"
	success "Restore complete: $file"
}

cmd_download() {
	local ip="$1"
	local url="http://$ip:$PORT"
	local out_path="$TMP_DIR"
	log "⬇Downloading from: $url"
	wget -q -O "$out_path" "$url" || {
		die "Download failed"
	}
	cmd_restore "$out_path"
}

cmd_list() {
	log "Backups in $BACKUP_DIR:"
	ls -lh "$BACKUP_DIR"/*.zip 2>/dev/null || log "No backups found."
}

cmd_version() {
	printf "%s %s\n" "$SCRIPT_NAME" "$VERSION"
}

# ===================================
# ARGUMENT PARSING
# ===================================
parse_arguments() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--dir)
			BACKUP_DIR="$2"
			shift
			;;
		--dest)
			DESTINATION="$2"
			shift
			;;
		--tmp)
			TMP_DIR="$2"
			shift
			;;
		--file)
			ZIP_FILE="$2"
			shift
			;;
		--ip)
			IP_ADDRESS="$2"
			shift
			;;
		--port)
			PORT="$2"
			shift
			;;
		--output)
			OUTPUT_NAME="$2"
			shift
			;;
		--dirs)
			IFS=',' read -ra DIRS_TO_BACKUP <<<"$2"
			shift
			;;
		--exclude)
			IFS=',' read -ra EXCLUDE_PATTERN <<<"$2"
			shift
			;;
		--compress)
			COMPRESSION_LEVEL="-$2"
			shift
			;;
		--no-notify)
			NOTIFY=false
			shift
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		-d | --debug)
			DEBUG=true
			shift
			;;
		-h | --help)
			cmd_help
			exit 0
			;;
		-v | --version)
			cmd_version
			exit 0
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			shift
			;;
		esac
	done
}

# ===================================
# MAIN
# ===================================
main() {
	local command="${1:-help}"
	parse_arguments "$@"

	case "$command" in
	create) cmd_create ;;
	share) cmd_share ;;
	download)
		[[ -z "$IP_ADDRESS" ]] && die "Missing --ip option for download command"
		cmd_download "$IP_ADDRESS"
		;;
	restore)
		[[ -z "$ZIP_FILE" ]] && die "Missing --file option for restore command"
		cmd_restore "$ZIP_FILE"
		;;
	list) cmd_list ;;
	help)
		cmd_help
		;;
	version)
		cmd_version
		;;
	*)
		die "Unknown command: '$command'. Use '$SCRIPT_NAME help'."
		;;
	esac
}

main "$@"
