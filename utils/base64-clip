#!/usr/bin/env bash
set -euo pipefail

# ===================================
# METADATA
# ===================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="1.1.0"

# ===================================
# COLORS
# ===================================
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
	readonly RED=$'\033[0;31m'
	readonly GREEN=$'\033[0;32m'
	readonly YELLOW=$'\033[0;33m'
	readonly BLUE=$'\033[0;34m'
	readonly MAGENTA=$'\033[0;35m'
	readonly BOLD=$'\033[1m'
	readonly DIM=$'\033[2m'
	readonly NC=$'\033[0m'
else
	readonly RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' BOLD='' DIM='' NC=''
fi

# ===================================
# CONFIGURATION
# ===================================
DEBUG=false
QUIET=false
FILE_PATH=""
OUTPUT_FORMAT="base64"
WRAP_WIDTH=""

# ===================================
# LOGGING FUNCTIONS
# ===================================
log() { [[ "$QUIET" != true ]] && printf "${BLUE}▶${NC} %s\n" "$*" || true; }
warn() { printf "${YELLOW}⚠${NC} %s\n" "$*" >&2; }
error() { printf "${RED}✗${NC} %s\n" "$*" >&2; }
success() { [[ "$QUIET" != true ]] && printf "${GREEN}✓${NC} %s\n" "$*" || true; }
debug() { [[ "$DEBUG" == true ]] && printf "${MAGENTA}⚈${NC} DEBUG: %s\n" "$*" >&2 || true; }
die() {
	error "$*"
	exit 1
}

# ===================================
# UTILITIES
# ===================================
require_command() {
	local cmd="$1" hint="${2:-$1}"
	command -v "$cmd" >/dev/null 2>&1 || die "'$cmd' not found. Install: $hint"
}

print_summary() {
	printf "\n${BOLD}Base64 Clipboard CLI${NC}\n"
	printf "File:        %s\n" "$FILE_PATH"
	printf "Format:      %s\n" "$OUTPUT_FORMAT"
	if [[ -n "$WRAP_WIDTH" ]]; then
		printf "Wrap Width:  %s\n" "$WRAP_WIDTH"
	fi
}

validate_file() {
	local file="$1"
	if [[ ! -f "$file" ]]; then
		die "File not found: $file"
	fi
	if [[ ! -r "$file" ]]; then
		die "File not readable: $file"
	fi
	debug "File validated: $file ($(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "unknown") bytes)"
}

detect_clipboard_tool() {
	if command -v xclip &>/dev/null; then
		echo "xclip"
	elif command -v pbcopy &>/dev/null; then
		echo "pbcopy"
	elif command -v wl-copy &>/dev/null; then
		echo "wl-copy"
	else
		die "No clipboard utility found. Install: xclip (Linux), pbcopy (macOS), or wl-copy (Wayland)"
	fi
}

encode_file() {
	local file="$1"
	local encoded

	debug "Encoding file with format: $OUTPUT_FORMAT"

	case "$OUTPUT_FORMAT" in
	base64)
		if [[ -n "$WRAP_WIDTH" ]]; then
			encoded=$(base64 "$file" | tr -d '\n' | fold -w "$WRAP_WIDTH")
		else
			encoded=$(base64 "$file" | tr -d '\n')
		fi
		;;
	base64-multiline)
		encoded=$(base64 "$file")
		;;
	hex)
		encoded=$(xxd -p "$file" | tr -d '\n')
		if [[ -n "$WRAP_WIDTH" ]]; then
			encoded=$(echo "$encoded" | fold -w "$WRAP_WIDTH")
		fi
		;;
	*)
		die "Unknown output format: $OUTPUT_FORMAT"
		;;
	esac

	echo "$encoded"
}

copy_to_clipboard() {
	local content="$1"
	local tool
	tool=$(detect_clipboard_tool)

	debug "Using clipboard tool: $tool"
	debug "Content length: ${#content} characters"

	case "$tool" in
	xclip)
		echo "$content" | xclip -selection clipboard
		success "Copied to clipboard via xclip"
		;;
	pbcopy)
		echo "$content" | pbcopy
		success "Copied to clipboard via pbcopy"
		;;
	wl-copy)
		echo "$content" | wl-copy
		success "Copied to clipboard via wl-copy"
		;;
	esac
}

# ===================================
# COMMANDS
# ===================================
cmd_help() {
	cat <<EOF
${BOLD}${SCRIPT_NAME}${NC} - File encoding and clipboard utility

${BOLD}USAGE:${NC}
  $SCRIPT_NAME [OPTIONS] COMMAND

${BOLD}COMMANDS:${NC}
  ${GREEN}copy${NC}        Encode a file and copy it to clipboard
  ${GREEN}encode${NC}      Encode a file and output to stdout
  ${GREEN}help${NC}        Show this help
  ${GREEN}version${NC}     Show version

${BOLD}OPTIONS:${NC}
  ${YELLOW}--file${NC} <path>              File to encode (required)
  ${YELLOW}--format${NC} <fmt>             Output format: base64, base64-multiline, hex (default: base64)
  ${YELLOW}--wrap${NC} <width>             Wrap lines at specified width
  ${YELLOW}-q, --quiet${NC}                Minimize output
  ${YELLOW}-d, --debug${NC}                Enable debug output
  ${YELLOW}-h, --help${NC}                 Show help
  ${YELLOW}-v, --version${NC}              Show version

${BOLD}OUTPUT FORMATS:${NC}
  base64           - Single line Base64 encoding
  base64-multiline - Multi-line Base64 encoding (as per base64 command)
  hex              - Hexadecimal encoding

${BOLD}EXAMPLES:${NC}
  $SCRIPT_NAME copy --file /path/to/file.txt
  $SCRIPT_NAME encode --file image.png --format hex
  $SCRIPT_NAME copy --file config.json --format base64 --wrap 64
EOF
}

cmd_version() {
	printf "%s %s\n" "$SCRIPT_NAME" "$VERSION"
}

cmd_copy() {
	validate_file "$FILE_PATH"
	local encoded
	encoded=$(encode_file "$FILE_PATH")
	copy_to_clipboard "$encoded"
}

cmd_encode() {
	validate_file "$FILE_PATH"
	local encoded
	encoded=$(encode_file "$FILE_PATH")
	echo "$encoded"
}

# ===================================
# ARGUMENT PARSING
# ===================================
parse_arguments() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--file)
			FILE_PATH="${2:?Missing value for $1}"
			shift 2
			;;
		--format)
			OUTPUT_FORMAT="${2:?Missing value for $1}"
			case "$OUTPUT_FORMAT" in
			base64 | base64-multiline | hex) ;;
			*) die "Invalid format: $OUTPUT_FORMAT. Use base64, base64-multiline, or hex" ;;
			esac
			shift 2
			;;
		--wrap)
			WRAP_WIDTH="${2:?Missing value for $1}"
			if ! [[ "$WRAP_WIDTH" =~ ^[0-9]+$ ]] || [[ "$WRAP_WIDTH" -lt 1 ]]; then
				die "Invalid wrap width: $WRAP_WIDTH. Must be a positive integer."
			fi
			shift 2
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		-d | --debug)
			DEBUG=true
			shift
			;;
		-h | --help)
			cmd_help
			exit 0
			;;
		-v | --version)
			cmd_version
			exit 0
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			shift
			;;
		esac
	done
}

# ===================================
# MAIN
# ===================================
main() {
	local command="${1:-help}"
	parse_arguments "$@"

	# Execute command
	case "$command" in
	copy)
		[[ -z "$FILE_PATH" ]] && die "File is required for $command command. Use --file <path>"
		print_summary
		cmd_copy
		;;
	encode)
		[[ -z "$FILE_PATH" ]] && die "File is required for $command command. Use --file <path>"
		print_summary
		cmd_encode
		;;
	help)
		cmd_help
		;;
	version)
		cmd_version
		;;
	*)
		die "Unknown command: '$command'. Use '$SCRIPT_NAME help'."
		;;
	esac
}

main "$@"
