#!/usr/bin/env bash
set -euo pipefail

# ===================================
# METADATA
# ===================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.0.0"
readonly PID_FILE="/tmp/${SCRIPT_NAME}.pid"

# ===================================
# COLORS
# ===================================
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
	readonly RED=$'\033[0;31m'
	readonly GREEN=$'\033[0;32m'
	readonly YELLOW=$'\033[0;33m'
	readonly BLUE=$'\033[0;34m'
	readonly MAGENTA=$'\033[0;35m'
	readonly BOLD=$'\033[1m'
	readonly DIM=$'\033[2m'
	readonly NC=$'\033[0m'
else
	readonly RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' BOLD='' DIM='' NC=''
fi

# ===================================
# CONFIGURATION
# ===================================
INTERVAL=60
PIXELS=1
METHOD="mouse"
DURATION=""
QUIET=false
DEBUG=false

# ===================================
# LOGGING FUNCTIONS
# ===================================
log() { [[ "$QUIET" != true ]] && printf "${BLUE}▶${NC} %s\n" "$*"; }
warn() { printf "${YELLOW}⚠${NC} %s\n" "$*" >&2; }
error() { printf "${RED}✗${NC} %s\n" "$*" >&2; }
success() { [[ "$QUIET" != true ]] && printf "${GREEN}✓${NC} %s\n" "$*"; }
debug() { [[ "$DEBUG" == true ]] && printf "${MAGENTA}⚈${NC} DEBUG: %s\n" "$*" >&2; }
die() {
	error "$*"
	exit 1
}

# ===================================
# UTILITY FUNCTIONS
# ===================================
require_command() {
	if ! command -v "$1" >/dev/null 2>&1; then
		die "'$1' not found. Install with: sudo apt install ${2:-$1}"
	fi
}

is_running() {
	[[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

# ===================================
# KEEP-AWAKE METHODS
# ===================================
mouse_jiggle() {
	local mouse_info
	mouse_info=$(xdotool getmouselocation --shell)
	eval "$mouse_info"
	xdotool mousemove $((X + PIXELS)) "$Y" >/dev/null 2>&1 || die "Failed to move mouse"
	sleep 0.1
	xdotool mousemove "$X" "$Y" >/dev/null 2>&1 || die "Failed to reset mouse position"
	debug "Mouse moved at position ($X, $Y)"
}

key_tap() {
	xdotool key shift+F24 2>/dev/null
	debug "Harmless keypress sent"
}

run_caffeine() {
	debug "Starting caffeine in daemon mode"
	caffeine &
}

perform_keep_awake() {
	case "$METHOD" in
	mouse) mouse_jiggle ;;
	key) key_tap ;;
	caffeine) run_caffeine ;;
	*) die "Unknown method: $METHOD" ;;
	esac
}

# ===================================
# VALIDATION FUNCTIONS
# ===================================
validate_positive_integer() {
	local value="$1"
	local name="$2"
	if [[ ! "$value" =~ ^[1-9][0-9]*$ ]]; then
		die "Invalid $name: '$value' (must be positive integer)"
	fi
}

validate_dependencies() {
	case "$METHOD" in
	mouse | key) require_command xdotool ;;
	caffeine) require_command caffeine ;;
	esac
}

# ===================================
# COMMAND IMPLEMENTATIONS
# ===================================
cmd_run() {
	if is_running; then
		die "Already running (PID: $(cat "$PID_FILE"))"
	fi
	validate_dependencies
	local end_time=""
	printf "\n${BOLD}Starting Keep-Awake Service${NC}\n"
	printf "Method:   ${GREEN}%s${NC}\n" "$METHOD"
	printf "Interval: ${GREEN}%s${NC} seconds\n" "$INTERVAL"
	[[ "$METHOD" == "mouse" ]] && printf "Movement: ${GREEN}%s${NC} pixels\n" "$PIXELS"
	[[ -n "$DURATION" ]] && printf "Duration: ${GREEN}%s${NC} seconds\n" "$DURATION"
	printf "\nPress ${BOLD}Ctrl+C${NC} to stop\n\n"
	if [[ -n "$DURATION" ]]; then
		end_time=$(($(date +%s) + DURATION))
		debug "Will stop at: $(date -d "@$end_time")"
	fi
	log "Starting keep-awake loop..."
	echo $$ >"$PID_FILE"
	while true; do
		if [[ -n "$end_time" ]] && (($(date +%s) >= end_time)); then
			success "Duration limit reached - stopping"
			break
		fi
		perform_keep_awake &
		success "Keep-awake service is running"
		sleep "$INTERVAL"
	done
}

cmd_stop() {
	if ! is_running; then
		warn "Service is not running"
		exit 1
	fi
	local pid
	pid=$(cat "$PID_FILE")
	if kill "$pid" 2>/dev/null; then
		success "Service stopped successfully (PID: $pid)"
		rm -f "$PID_FILE"
	else
		die "Failed to stop service (PID: $pid)"
	fi
}

cmd_status() {
	if is_running; then
		local pid uptime
		pid=$(cat "$PID_FILE")
		uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ' || echo "unknown")
		printf "\n${BOLD}Service Status${NC}\n"
		printf "Status:  ${GREEN}Running${NC}\n"
		printf "PID:     ${GREEN}%s${NC}\n" "$pid"
		printf "Uptime:  ${GREEN}%s${NC}\n" "$uptime"
	else
		printf "\n${BOLD}Service Status${NC}\n"
		printf "Status:  ${YELLOW}Not running${NC}\n"
		exit 1
	fi
}

# ===================================
# HELP & VERSION
# ===================================
show_help() {
	cat <<EOF
${BOLD}${SCRIPT_NAME}${NC} - Keep your Linux system awake

${BOLD}USAGE:${NC}
    $SCRIPT_NAME [OPTIONS] COMMAND

${BOLD}COMMANDS:${NC}
    ${GREEN}run${NC}       Start the keep-awake service
    ${GREEN}stop${NC}      Stop the running service  
    ${GREEN}status${NC}    Show current service status
    ${GREEN}help${NC}      Show this help message
    ${GREEN}version${NC}   Show version information

${BOLD}OPTIONS:${NC}
    ${YELLOW}-i, --interval${NC} SECONDS    Interval between actions (default: $INTERVAL)
    ${YELLOW}-m, --method${NC} METHOD       Keep-awake method (default: $METHOD)
    ${YELLOW}-p, --pixels${NC} PIXELS       Mouse movement distance (default: $PIXELS)
    ${YELLOW}-t, --time${NC} SECONDS        Duration limit in seconds
    ${YELLOW}-q, --quiet${NC}               Minimize output messages
    ${YELLOW}-d, --debug${NC}               Enable debug output
    ${YELLOW}-h, --help${NC}                Show this help message
    ${YELLOW}-v, --version${NC}             Show version information

${BOLD}METHODS:${NC}
    ${GREEN}mouse${NC}     Move cursor slightly (requires: xdotool)
    ${GREEN}key${NC}       Send harmless keypress (requires: xdotool)  
    ${GREEN}caffeine${NC}  Use caffeine utility (requires: caffeine)

${BOLD}EXAMPLES:${NC}
    $SCRIPT_NAME run                        ${DIM}# Start with default settings${NC}
    $SCRIPT_NAME run -i 30 -m key           ${DIM}# Keyboard method, 30s interval${NC}
    $SCRIPT_NAME run -t 3600 --quiet        ${DIM}# Run quietly for 1 hour${NC}
    $SCRIPT_NAME status                     ${DIM}# Check service status${NC}

${BOLD}INSTALLATION:${NC}
    ${DIM}# For mouse/key methods:${NC}
    sudo apt install xdotool
    
    ${DIM}# For caffeine method:${NC}  
    sudo apt install caffeine
EOF
}

show_version() {
	printf "%s %s\n" "$SCRIPT_NAME" "$VERSION"
}

# ===================================
# ARGUMENT PARSING
# ===================================
parse_arguments() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-i | --interval)
			INTERVAL="${2:?Missing argument for $1}"
			validate_positive_integer "$INTERVAL" "interval"
			shift 2
			;;
		-m | --method)
			METHOD="${2:?Missing argument for $1}"
			shift 2
			;;
		-p | --pixels)
			PIXELS="${2:?Missing argument for $1}"
			validate_positive_integer "$PIXELS" "pixels"
			shift 2
			;;
		-t | --time)
			DURATION="${2:?Missing argument for $1}"
			validate_positive_integer "$DURATION" "duration"
			shift 2
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		-d | --debug)
			DEBUG=true
			shift
			;;
		-h | --help)
			show_help
			exit 0
			;;
		-v | --version)
			show_version
			exit 0
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			shift
			;;
		esac
	done
}

# ===================================
# MAIN FUNCTION
# ===================================
main() {
	local command="${1:-help}"
	parse_arguments "$@"

	# Execute command
	case "$command" in
	run) cmd_run ;;
	stop) cmd_stop ;;
	status) cmd_status ;;
	help) show_help ;;
	version) show_version ;;
	*) die "Unknown command: '$command'. Use '$SCRIPT_NAME help' for usage information." ;;
	esac
}

# ===================================
# ENTRY POINT
# ===================================
main "$@"
