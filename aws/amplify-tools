#!/usr/bin/env bash
set -euo pipefail

# ===================================
# METADATA
# ===================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.0.0"

# ===================================
# COLORS
# ===================================
if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
	readonly RED=$'\033[0;31m'
	readonly GREEN=$'\033[0;32m'
	readonly YELLOW=$'\033[0;33m'
	readonly BLUE=$'\033[0;34m'
	readonly MAGENTA=$'\033[0;35m'
	readonly BOLD=$'\033[1m'
	readonly DIM=$'\033[2m'
	readonly NC=$'\033[0m'
else
	readonly RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' BOLD='' DIM='' NC=''
fi

# ===================================
# CONFIGURATION
# ===================================
DEBUG=false
QUIET=false
APP_ID=""
PROFILE=""
REGION=""
ACCESS_KEY=""
SECRET_KEY=""
SESSION_TOKEN=""
OUTPUT_FORMAT="json"
OUTPUT_FILE=""

# Default configuration
readonly DEFAULT_REGION="${AWS_REGION:-ca-central-1}"
readonly DEFAULT_PROFILE="${AWS_PROFILE:-default}"

# ===================================
# LOGGING FUNCTIONS
# ===================================
log() { [[ "$QUIET" != true ]] && printf "${BLUE}▶${NC} %s\n" "$*" || true; }
warn() { printf "${YELLOW}⚠${NC} %s\n" "$*" >&2; }
error() { printf "${RED}✗${NC} %s\n" "$*" >&2; }
success() { [[ "$QUIET" != true ]] && printf "${GREEN}✓${NC} %s\n" "$*" || true; }
debug() { [[ "$DEBUG" == true ]] && printf "${MAGENTA}⚈${NC} DEBUG: %s\n" "$*" >&2 || true; }
die() {
	error "$*"
	exit 1
}

# ===================================
# UTILITIES
# ===================================
require_command() {
	local cmd="$1" hint="${2:-$1}"
	command -v "$cmd" >/dev/null 2>&1 || die "'$cmd' not found. Install: $hint"
}

validate_app_id() {
	local app_id="$1"
	if [[ ! "$app_id" =~ ^[a-zA-Z0-9]{1,20}$ ]]; then
		die "Invalid app ID: $app_id. Must be alphanumeric, 1-20 characters."
	fi
	debug "App ID validated: $app_id"
}

validate_output_file() {
	local file="$1"
	local dir
	dir=$(dirname "$file")

	if [[ ! -d "$dir" ]]; then
		die "Output directory does not exist: $dir"
	fi

	if [[ ! -w "$dir" ]]; then
		die "Output directory is not writable: $dir"
	fi

	if [[ -f "$file" && ! -w "$file" ]]; then
		die "Output file exists but is not writable: $file"
	fi

	debug "Output file validated: $file"
}

build_aws_options() {
	local region="${REGION:-$DEFAULT_REGION}"
	local profile="${PROFILE:-$DEFAULT_PROFILE}"

	AWS_OPTS=(--region "$region" --output json)

	debug "Using region: $region"

	if [[ -n "$ACCESS_KEY" && -n "$SECRET_KEY" ]]; then
		export AWS_ACCESS_KEY_ID="$ACCESS_KEY"
		export AWS_SECRET_ACCESS_KEY="$SECRET_KEY"
		[[ -n "$SESSION_TOKEN" ]] && export AWS_SESSION_TOKEN="$SESSION_TOKEN"
		debug "Using credentials from environment variables"
	else
		AWS_OPTS+=(--profile "$profile")
		debug "Using profile: $profile"
	fi
}

output_json() {
	local json_data="$1"

	# Always output to terminal
	echo "$json_data"

	# Additionally save to file if specified
	if [[ -n "$OUTPUT_FILE" ]]; then
		validate_output_file "$OUTPUT_FILE"
		echo "$json_data" >"$OUTPUT_FILE"
		success "Output saved to: $OUTPUT_FILE"
	fi
}

get_apps() {
	debug "Fetching Amplify apps"
	aws amplify list-apps "${AWS_OPTS[@]}" | jq -c '.apps[]'
}

get_branches() {
	local app_id="$1"
	debug "Fetching branches for app: $app_id"

	# Add timeout to prevent hanging
	if ! timeout 30 aws amplify list-branches --app-id "$app_id" "${AWS_OPTS[@]}" 2>/dev/null | jq -c '.branches'; then
		debug "Failed to fetch branches for app: $app_id (timeout or error)"
		return 1
	fi
}

print_summary() {
	[[ "$QUIET" == true ]] && return

	printf "\n${BOLD}AWS Amplify CLI${NC}\n"
	printf "Region:         %s\n" "${REGION:-$DEFAULT_REGION}"
	printf "Profile:        %s\n" "${PROFILE:-$DEFAULT_PROFILE}"
	[[ -n "$APP_ID" ]] && printf "App ID:         %s\n" "$APP_ID"
	[[ -n "$OUTPUT_FILE" ]] && printf "Output File:    %s\n" "$OUTPUT_FILE"
	printf "Output Format:  %s\n" "$OUTPUT_FORMAT"
}

# ===================================
# COMMANDS
# ===================================
cmd_help() {
	cat <<EOF
${BOLD}${SCRIPT_NAME}${NC} - AWS Amplify management tool

${BOLD}USAGE:${NC}
  $SCRIPT_NAME [OPTIONS] COMMAND

${BOLD}COMMANDS:${NC}
  ${GREEN}list${NC}            List Amplify apps with their branches
  ${GREEN}apps${NC}            List raw Amplify apps JSON
  ${GREEN}branches${NC}        List raw branches JSON for specific app
  ${GREEN}validate${NC}        Validate AWS configuration and connectivity
  ${GREEN}help${NC}            Show this help
  ${GREEN}version${NC}         Show version

${BOLD}OPTIONS:${NC}
  ${YELLOW}--app-id${NC} <id>              App ID (required for branches command)
  ${YELLOW}--profile${NC} <n>           AWS named profile (default: \$AWS_PROFILE or 'default')
  ${YELLOW}--region${NC} <region>          AWS region (default: \$AWS_REGION or 'ca-central-1')
  ${YELLOW}--access-key${NC} <key>         AWS Access Key ID
  ${YELLOW}--secret-key${NC} <key>         AWS Secret Access Key
  ${YELLOW}--session-token${NC} <token>    AWS Session Token (optional)
  ${YELLOW}--output${NC} <path>            Save JSON output to file
  ${YELLOW}--format${NC} <json|table>      Output format (default: json)
  ${YELLOW}-q, --quiet${NC}                Minimize output
  ${YELLOW}-d, --debug${NC}                Enable debug output
  ${YELLOW}-h, --help${NC}                 Show help
  ${YELLOW}-v, --version${NC}              Show version

${BOLD}EXAMPLES:${NC}
  # List all apps and branches
  $SCRIPT_NAME list --profile myprofile

  # Get raw apps data
  $SCRIPT_NAME apps --region us-west-2

  # Get branches for specific app
  $SCRIPT_NAME branches --app-id abc123xyz --output branches.json

  # Use temporary credentials with file output
  $SCRIPT_NAME list --access-key AKIA... --secret-key xyz... --region us-east-1 --output apps.json

  # Validate configuration
  $SCRIPT_NAME validate --profile production
EOF
}

cmd_version() {
	printf "%s %s\n" "$SCRIPT_NAME" "$VERSION"
}

cmd_validate() {
	require_command aws "AWS CLI v2"
	require_command jq "jq JSON processor"

	build_aws_options
	print_summary

	log "Validating AWS configuration..."

	# Test AWS connectivity
	if aws sts get-caller-identity "${AWS_OPTS[@]}" >/dev/null 2>&1; then
		success "AWS credentials are valid"
	else
		die "AWS credentials validation failed"
	fi

	# Test Amplify permissions
	if aws amplify list-apps "${AWS_OPTS[@]}" --max-items 1 >/dev/null 2>&1; then
		success "AWS Amplify permissions are valid"
	else
		die "AWS Amplify permissions validation failed"
	fi
}

cmd_apps() {
	require_command aws "AWS CLI v2"
	require_command jq "jq JSON processor"

	build_aws_options
	print_summary

	local apps_data
	apps_data=$(get_apps | jq -s .)

	if [[ "$apps_data" == "[]" ]]; then
		[[ "$QUIET" != true ]] && warn "No Amplify apps found"
		output_json "[]"
		return
	fi

	local app_count
	app_count=$(echo "$apps_data" | jq 'length')
	success "Found $app_count Amplify apps"

	output_json "$apps_data"
}

cmd_branches() {
	[[ -z "$APP_ID" ]] && die "App ID is required for branches command. Use --app-id <id>"

	require_command aws "AWS CLI v2"
	require_command jq "jq JSON processor"

	validate_app_id "$APP_ID"
	build_aws_options
	print_summary

	local branches_data
	debug "Attempting to fetch branches for app: $APP_ID"
	if ! branches_data=$(get_branches "$APP_ID"); then
		die "Failed to fetch branches for app: $APP_ID"
	fi

	local branch_count
	branch_count=$(echo "$branches_data" | jq 'length')
	success "Found $branch_count branches for app: $APP_ID"

	output_json "$branches_data"
}

cmd_list() {
	require_command aws "AWS CLI v2"
	require_command jq "jq JSON processor"

	build_aws_options
	print_summary

	local apps_json
	mapfile -t apps_json < <(get_apps)

	if [[ ${#apps_json[@]} -eq 0 ]]; then
		[[ "$QUIET" != true ]] && warn "No Amplify apps found"
		output_json "[]"
		return
	fi

	success "Processing ${#apps_json[@]} Amplify apps"

	local combined_output=""
	combined_output+="["
	local first=true
	local processed=0

	for app_json in "${apps_json[@]}"; do
		local app_id app_name domain repo platform create_time update_time status prod_branch
		app_id=$(jq -r '.appId' <<<"$app_json")
		app_name=$(jq -r '.name' <<<"$app_json")
		domain=$(jq -r '.defaultDomain' <<<"$app_json")
		repo=$(jq -r '.repository' <<<"$app_json")
		platform=$(jq -r '.platform' <<<"$app_json")
		create_time=$(jq -r '.createTime' <<<"$app_json")
		update_time=$(jq -r '.updateTime' <<<"$app_json")
		status=$(jq -r '.productionBranch.status // "UNKNOWN"' <<<"$app_json")
		prod_branch=$(jq -r '.productionBranch.branchName // "none"' <<<"$app_json")

		debug "Processing app: $app_name ($app_id)"

		local branches_data
		debug "Attempting to fetch branches for app: $app_id"
		if ! branches_data=$(get_branches "$app_id"); then
			warn "Failed to fetch branches for app: $app_name ($app_id)"
			branches_data="[]"
		else
			debug "Successfully fetched branches for app: $app_name"
		fi

		[[ "$first" == false ]] && combined_output+=","
		first=false

		local app_json_output
		app_json_output=$(jq -n \
			--arg id "$app_id" \
			--arg name "$app_name" \
			--arg domain "$domain" \
			--arg repo "$repo" \
			--arg platform "$platform" \
			--arg create "$create_time" \
			--arg update "$update_time" \
			--arg status "$status" \
			--arg prod_branch "$prod_branch" \
			--argjson branches "$branches_data" \
			'{
				appId: $id,
				name: $name,
				repository: $repo,
				defaultDomain: $domain,
				platform: $platform,
				status: $status,
				productionBranch: $prod_branch,
				createTime: $create,
				updateTime: $update,
				branches: $branches
			}')
		combined_output+="$app_json_output"
		processed=$((processed + 1))
	done

	combined_output+="]"
	success "Processed $processed apps successfully"

	output_json "$combined_output"
}

# ===================================
# ARGUMENT PARSING
# ===================================
parse_arguments() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--app-id)
			APP_ID="${2:?Missing value for $1}"
			shift 2
			;;
		--profile)
			PROFILE="${2:?Missing value for $1}"
			shift 2
			;;
		--region)
			REGION="${2:?Missing value for $1}"
			shift 2
			;;
		--access-key)
			ACCESS_KEY="${2:?Missing value for $1}"
			shift 2
			;;
		--secret-key)
			SECRET_KEY="${2:?Missing value for $1}"
			shift 2
			;;
		--session-token)
			SESSION_TOKEN="${2:?Missing value for $1}"
			shift 2
			;;
		--output)
			OUTPUT_FILE="${2:?Missing value for $1}"
			shift 2
			;;
		--format)
			OUTPUT_FORMAT="${2:?Missing value for $1}"
			shift 2
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		-d | --debug)
			DEBUG=true
			shift
			;;
		-h | --help)
			cmd_help
			exit 0
			;;
		-v | --version)
			cmd_version
			exit 0
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			shift
			;;
		esac
	done
}

# ===================================
# MAIN
# ===================================
main() {
	local command="${1:-help}"
	parse_arguments "$@"

	# Validate output format
	if [[ "$OUTPUT_FORMAT" != "json" && "$OUTPUT_FORMAT" != "table" ]]; then
		die "Invalid output format: $OUTPUT_FORMAT. Use 'json' or 'table'"
	fi

	# Execute command
	case "$command" in
	list)
		cmd_list
		;;
	apps)
		cmd_apps
		;;
	branches)
		cmd_branches
		;;
	validate)
		cmd_validate
		;;
	help)
		cmd_help
		;;
	version)
		cmd_version
		;;
	*)
		die "Unknown command: '$command'. Use '$SCRIPT_NAME help' for available commands."
		;;
	esac
}

main "$@"
